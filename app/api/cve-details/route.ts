import { NextResponse } from 'next/server';

// Detailed environment check
console.log('Environment check:', {
  NODE_ENV: process.env.NODE_ENV,
  NVD_API_KEY: process.env.NVD_API_KEY ? 'Present' : 'Missing',
  API_URL: process.env.NVD_API_URL || 'https://services.nvd.nist.gov/rest/json/cves/2.0',
  // Log all environment variables (excluding sensitive ones)
  envKeys: Object.keys(process.env).filter(key => !key.includes('KEY') && !key.includes('SECRET'))
});

const NVD_API_KEY = process.env.NVD_API_KEY;
const NVD_API_URL = 'https://services.nvd.nist.gov/rest/json/cves/2.0';

interface NVDMetrics {
  cvssMetricV31?: [{
    cvssData: {
      baseScore: number;
      baseSeverity: string;
    };
  }];
  cvssMetricV2?: [{
    cvssData: {
      baseScore: number;
      severity: string;
    };
  }];
}

interface NVDReference {
  url: string;
  tags: string[];
}

interface NVDCVEData {
  id: string;
  descriptions: Array<{
    lang: string;
    value: string;
  }>;
  published: string;
  lastModified: string;
  metrics: NVDMetrics;
  references: NVDReference[];
  configurations?: Array<{
    nodes: Array<{
      cpeMatch: Array<{
        criteria: string;
        matchCriteriaId: string;
        vulnerable: boolean;
      }>;
    }>;
  }>;
  vulnStatus: string;
}

interface NVDResponse {
  resultsPerPage: number;
  startIndex: number;
  totalResults: number;
  format: string;
  version: string;
  vulnerabilities: Array<{
    cve: NVDCVEData;
  }>;
}

// Test function to verify API connectivity
async function testNVDAPI() {
  try {
    const testUrl = new URL(NVD_API_URL);
    testUrl.searchParams.append('resultsPerPage', '1');
    
    console.log('Testing NVD API connectivity...');
    console.log('Test URL:', testUrl.toString());
    
    const response = await fetch(testUrl.toString(), {
      headers: {
        'apiKey': NVD_API_KEY || '',
        'Content-Type': 'application/json',
        'User-Agent': 'Cyber-Threat-Dashboard/1.0',
        'Accept': 'application/json'
      },
      method: 'GET'
    });

    console.log('Test API Response:', {
      status: response.status,
      statusText: response.statusText,
      contentType: response.headers.get('content-type'),
      contentLength: response.headers.get('content-length')
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('Test API Error:', {
        status: response.status,
        statusText: response.statusText,
        body: errorText
      });
      return false;
    }

    return true;
  } catch (error) {
    console.error('Test API Error:', error);
    return false;
  }
}

export async function GET() {
  console.log('API Route called');
  
  // Test API connectivity first
  const apiTest = await testNVDAPI();
  if (!apiTest) {
    return NextResponse.json(
      { 
        error: 'NVD API test failed',
        details: 'Could not connect to NVD API. Check API key and network connectivity.'
      },
      { status: 500 }
    );
  }

  if (!NVD_API_KEY) {
    console.error('NVD API key is missing. Check your .env file and server restart.');
    return NextResponse.json(
      { 
        error: 'NVD API key is not configured',
        details: 'Please check your .env file and restart the server'
      },
      { status: 500 }
    );
  }

  try {
    // Get CVEs from the last 90 days to get more results
    const ninetyDaysAgo = new Date();
    ninetyDaysAgo.setDate(ninetyDaysAgo.getDate() - 90);
    const pubStartDate = ninetyDaysAgo.toISOString();
    const pubEndDate = new Date().toISOString();
    
    // Construct the URL with proper parameters
    const url = new URL(NVD_API_URL);
    url.searchParams.append('pubStartDate', pubStartDate);
    url.searchParams.append('pubEndDate', pubEndDate);
    url.searchParams.append('resultsPerPage', '50'); // Increased from 20 to 50
    
    console.log('Request details:', {
      url: url.toString(),
      pubStartDate,
      pubEndDate,
      apiKey: NVD_API_KEY ? 'Present' : 'Missing',
      headers: {
        'apiKey': NVD_API_KEY ? 'Present' : 'Missing',
        'Content-Type': 'application/json',
        'User-Agent': 'Cyber-Threat-Dashboard/1.0',
        'Accept': 'application/json'
      }
    });

    const response = await fetch(url.toString(), { 
      headers: {
        'apiKey': NVD_API_KEY,
        'Content-Type': 'application/json',
        'User-Agent': 'Cyber-Threat-Dashboard/1.0',
        'Accept': 'application/json'
      },
      cache: 'no-store',
      method: 'GET'
    });

    console.log('NVD API Response:', {
      status: response.status,
      statusText: response.statusText,
      contentType: response.headers.get('content-type'),
      contentLength: response.headers.get('content-length')
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('NVD API Error:', {
        status: response.status,
        statusText: response.statusText,
        body: errorText
      });
      
      return NextResponse.json(
        { 
          error: `NVD API error: ${response.status}`,
          details: errorText || 'No error details available'
        },
        { status: response.status }
      );
    }

    const data: NVDResponse = await response.json();
    
    if (!data.vulnerabilities) {
      console.error('Invalid NVD API response:', data);
      return NextResponse.json(
        { 
          error: 'Invalid response from NVD API',
          details: 'Missing vulnerabilities data'
        },
        { status: 500 }
      );
    }

    const processedData = data.vulnerabilities.map(({ cve }) => {
      try {
        const metrics = cve.metrics.cvssMetricV31?.[0] || cve.metrics.cvssMetricV2?.[0];
        const cvssScore = metrics?.cvssData.baseScore || 0;
        
        // Handle both CVSS v3.1 and v2.0 severity
        let severity: string;
        if (cve.metrics.cvssMetricV31?.[0]) {
          severity = cve.metrics.cvssMetricV31[0].cvssData.baseSeverity;
        } else if (cve.metrics.cvssMetricV2?.[0]) {
          severity = cve.metrics.cvssMetricV2[0].cvssData.severity;
        } else {
          severity = 'Unknown';
        }
        
        const severityLevel = severity.toUpperCase();

        const affectedSystems = cve.configurations?.flatMap(config =>
          config.nodes.flatMap(node =>
            node.cpeMatch
              .filter(match => match.vulnerable)
              .map(match => {
                try {
                  const cpe = match.criteria.split(':');
                  return cpe.length >= 6 ? `${cpe[4]} ${cpe[5]}` : match.criteria;
                } catch (e) {
                  console.warn('Error parsing CPE:', e);
                  return match.criteria;
                }
              })
          )
        ) || [];

        return {
          id: cve.id,
          description: cve.descriptions.find(d => d.lang === 'en')?.value || 'No description available',
          publishedDate: cve.published,
          lastModifiedDate: cve.lastModified,
          cvssScore,
          severity: severityLevel,
          status: cve.vulnStatus,
          affectedSystems: [...new Set(affectedSystems)],
          references: cve.references.map(ref => ref.url),
          patches: [],
          exploitStatus: cve.references.some(ref => 
            ref.tags.some(tag => 
              tag.toLowerCase().includes('exploit')
            )
          ) ? 'Exploit Possible' : 'No Known Exploits'
        };
      } catch (e) {
        console.error('Error processing CVE:', cve.id, e);
        return null;
      }
    }).filter(Boolean);

    console.log('Successfully processed CVE data');
    return NextResponse.json({ cveList: processedData });
  } catch (error) {
    console.error('Unexpected error:', error);
    return NextResponse.json(
      { 
        error: 'Failed to fetch CVE data',
        details: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    );
  }
} 